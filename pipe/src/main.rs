#[macro_use]
extern crate log;

// extern crate env_logger;

use std::net::{TcpStream, TcpListener, ToSocketAddrs, IpAddr, Shutdown};
use std::sync::{Arc, Mutex};
use std::io::Read;
use std::thread;
use std::time::Duration;

use timely::dataflow::operators::capture::EventReader;
use timely::dataflow::operators::capture::event::{Event};
use timely::dataflow::operators::capture::event::EventIterator;

use logformat::pair::Pair;


fn main () {
    // env_logger::init();

    let peers = std::env::args().nth(1).expect("peers").parse::<usize>().expect("peers2");
    let from_ip = std::env::args().nth(2).expect("from_ip").parse::<String>().expect("from_ip2");
    let from_port = std::env::args().nth(3).expect("froom_port").parse::<u16>().expect("from_port2");

    println!("opening sockets");

    let sockets = open_sockets(from_ip.parse().expect("not an IP addr"), from_port, peers).expect("couldn't create sockets");
    let sockets = Arc::new(Mutex::new(sockets));

    println!("opened sockets");

    for i in 0..peers {
        let sockets = sockets.clone();
        println!("spawning thread");

        thread::spawn(move || {
            println!("spawned thread");
            // let mut streams: Vec<EventReader<Pair<u64, Duration>, timely_adapter::connect::CompEvent, _>> = make_reader(i, peers, sockets);
            let mut streams: Vec<_> = make_reader(i, peers, sockets);
            let mut buf = [0u8; 100000];

            for stream in streams.iter_mut() {
                loop {
                    let read = stream.read(&mut buf);
                    // if let Ok(x) = read {
                    //     println!("{:?}", x);
                    // }
                    // if let Ok(x) = read {
                    //     println!("{:?}", x);
                    // } else {
                    //     println!("{:?}",
                    // while let Some(event) = stream.next() {
                    //     println!("has a next");
                    //     match event {
                    //         Event::Progress(ref vec) => {
                    //             println!("progress");
                    //         },
                    //         Event::Messages(time, data) => {
                    //             println!("message")
                    //         }
                    //     }
                    // }
                }
            }
        });
    }

    // spin main thread
    loop {std::thread::sleep(std::time::Duration::from_millis(500));}
}

pub fn open_sockets(ip_addr: IpAddr, port: u16, source_peers: usize) -> Result<Vec<Option<TcpStream>>, ConnectError> {
    let socket_addr = (ip_addr, port).to_socket_addrs()?
        .next().ok_or(ConnectError::Other("Invalid listening address".to_string()))?;
    let listener = TcpListener::bind(socket_addr)?;
    Ok((0..source_peers).map(|_| {
        let socket = listener.incoming().next().expect("Socket unexpectedly unavailable");
        if let Ok(ref s) = &socket {
            s.set_nonblocking(true)?;
        }
        socket.map(Some)
    }).collect::<Result<Vec<_>, _>>()?)
}

/// Construct EventReaders that read data from sockets or file
/// and can stream it into timely dataflow.
pub fn make_reader(
    worker_index: usize,
    worker_peers: usize,
    sockets: Arc<Mutex<Vec<Option<TcpStream>>>>
    ) -> Vec<TcpStream> {
    // ) -> Vec<EventReader<T, E, TcpStream>> {

    let readers = sockets.lock().expect("couldn't lock sockets")
        .iter_mut().enumerate()
        .filter(|(i, _)| *i % worker_peers == worker_index)
        .map(|(_, s)| s.take().expect("socket missing, check the docs for make_replayers"))
        // .map(|r| EventReader::<T, E, _>::new(r))
        .collect::<Vec<_>>();
    assert!(readers.len() == 1);
    readers
}

/// An error generated by this crate's connect functions.
#[derive(Debug)]
pub enum ConnectError {
    IoError(std::io::Error),
    Other(String),
}

impl From<std::io::Error> for ConnectError {
    fn from(e: std::io::Error) -> Self {
        ConnectError::IoError(e)
    }
}
